<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Camera & Video App</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        button {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 1);
        }
        
        button:disabled {
            background: rgba(150, 150, 150, 0.5);
            cursor: not-allowed;
        }
        
        select {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 5px;
            font-weight: bold;
        }
        
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        
        #photo-preview, #video-preview {
            position: absolute;
            top: 20px;
            right: 20px;
            max-width: 200px;
            max-height: 150px;
            border: 2px solid white;
            border-radius: 5px;
            z-index: 100;
            display: none;
        }
        
        #recording-indicator, #countdown-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            z-index: 200;
            display: none;
            animation: pulse 1s infinite;
        }
        
        #countdown-overlay {
            background: rgba(0, 100, 255, 0.9);
            font-size: 48px;
            padding: 30px 40px;
            animation: countdownPulse 1s ease-in-out;
        }
        
        /* Hidden video element for camera */
        #camera-video {
            position: absolute;
            visibility: hidden;
            width: 1px;
            height: 1px;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        
        @keyframes countdownPulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Hidden video element for camera -->
        <video id="camera-video" autoplay playsinline></video>
        
        <div id="controls">
            <div class="control-group">
                <button id="startCamera">Start Camera</button>
                <button id="stopCamera" disabled>Stop Camera</button>
            </div>
            <div class="control-group">
                <select id="videoSelect">
                    <option value="">Select WebM Video</option>
                    <option value="video1">WebM Video 1</option>
                    <option value="video2">WebM Video 2</option>
                    <option value="video3">WebM Video 3</option>
                </select>
                <button id="playVideo" disabled>Play</button>
                <button id="stopVideo" disabled>Stop</button>
            </div>
            <div class="control-group">
                <select id="modelSelect">
                    <option value="">Select 3D Model</option>
                    <option value="model1">Animated Model 1</option>
                    <option value="model2">Animated Model 2</option>
                    <option value="model3">Animated Model 3</option>
                </select>
                <button id="loadModel" disabled>Load Model</button>
                <button id="removeModel" disabled>Remove Model</button>
            </div>
            <div class="control-group">
                <button id="takePhoto">Take Photo</button>
                <button id="recordVideo">Record 10s Video</button>
                <button id="stopRecording" disabled style="display: none;">Stop Recording</button>
            </div>
        </div>
        
        <div id="status">Ready to start</div>
        <img id="photo-preview" alt="Photo preview">
        <video id="video-preview" alt="Video preview" controls></video>
        <div id="recording-indicator">ðŸ”´ RECORDING<br><span id="countdown">10</span>s</div>
        <div id="countdown-overlay">3</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        let scene, camera, renderer, cameraTexture, videoTexture;
        let cameraStream, videoElement;
        let backgroundPlane, videoPlane;
        let isVideoPlaying = false;
        let cameraVideo; // Reference to the camera video element
        
        // 3D Model variables
        let gltfLoader;
        let currentModel = null;
        let animationMixer = null;
        let animationActions = [];
        let clock;
        
        // Video recording variables
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let recordingTimer;
        let countdownTimer;
        
        // Countdown variables
        let captureCountdownTimer;
        let isCounting = false;
        
        // Sample GLB model URLs (replace with your actual GLB files)
        const modelUrls = {
            model1: 'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
            model2: 'https://threejs.org/examples/models/gltf/Flamingo.glb',
            model3: 'https://threejs.org/examples/models/gltf/Parrot.glb'
        };
        const videoUrls = {
            video1: 'https://res.cloudinary.com/dzq7c0mxt/video/upload/v1748091424/movie-webm_fipc3a.webm',
            video2: 'https://test-videos.co.uk/vids/bigbuckbunny/webm/vp8/360/Big_Buck_Bunny_360_10s_1MB.webm',
            video3: 'https://test-videos.co.uk/vids/sintel/webm/vp9/240/Sintel_240_10s_1MB.webm'
        };
        
        function init() {
            // Get reference to camera video element
            cameraVideo = document.getElementById('camera-video');
            
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                preserveDrawingBuffer: true,
                alpha: true,
                antialias: true
            });
            renderer.setClearColor(0x000000, 0); // Transparent background
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Create background plane for camera
            const backgroundGeometry = new THREE.PlaneGeometry(16, 9);
            const backgroundMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0
            });
            backgroundPlane = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
            backgroundPlane.position.z = -2;
            scene.add(backgroundPlane);
            
            // Create video plane with transparent material
            const videoGeometry = new THREE.PlaneGeometry(4, 3);
            const videoMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0,
                alphaTest: 0.1 // This helps with transparent WebM rendering
            });
            videoPlane = new THREE.Mesh(videoGeometry, videoMaterial);
            videoPlane.position.set(2, 0, 0);
            scene.add(videoPlane);
            
            // Add some ambient lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // Add directional light for better 3D model visibility
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Initialize GLTF loader and clock
            gltfLoader = new THREE.GLTFLoader();
            clock = new THREE.Clock();
            
            // Set up event listeners
            setupEventListeners();
            
            // Start render loop
            animate();
            
            updateStatus('Three.js scene initialized. Click "Start Camera" to begin. WebM videos and 3D models supported.');
        }
        
        function setupEventListeners() {
            document.getElementById('startCamera').addEventListener('click', startCamera);
            document.getElementById('stopCamera').addEventListener('click', stopCamera);
            document.getElementById('videoSelect').addEventListener('change', onVideoSelect);
            document.getElementById('playVideo').addEventListener('click', playVideo);
            document.getElementById('stopVideo').addEventListener('click', stopVideo);
            document.getElementById('modelSelect').addEventListener('change', onModelSelect);
            document.getElementById('loadModel').addEventListener('click', loadModel);
            document.getElementById('removeModel').addEventListener('click', removeModel);
            document.getElementById('takePhoto').addEventListener('click', takePhoto);
            document.getElementById('recordVideo').addEventListener('click', recordVideo);
            document.getElementById('stopRecording').addEventListener('click', stopRecording);
            
            window.addEventListener('resize', onWindowResize);
        }
        
        async function startCamera() {
            try {
                // Request camera access with better compatibility
                const constraints = {
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                };
                
                // Try environment camera first, fallback to any camera
                try {
                    cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                } catch (e) {
                    // Fallback to any available camera
                    cameraStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                }
                
                // Set the stream to the video element
                cameraVideo.srcObject = cameraStream;
                
                // Wait for video to be ready
                cameraVideo.onloadedmetadata = () => {
                    // Create texture from video element
                    cameraTexture = new THREE.VideoTexture(cameraVideo);
                    cameraTexture.minFilter = THREE.LinearFilter;
                    cameraTexture.magFilter = THREE.LinearFilter;
                    cameraTexture.format = THREE.RGBFormat;
                    
                    // Apply texture to background plane
                    backgroundPlane.material = new THREE.MeshBasicMaterial({
                        map: cameraTexture,
                        side: THREE.DoubleSide
                    });
                    backgroundPlane.material.needsUpdate = true;
                    
                    updateStatus('Camera started successfully');
                    document.getElementById('startCamera').disabled = true;
                    document.getElementById('stopCamera').disabled = false;
                };
                
                // Handle any errors during playback
                cameraVideo.onerror = (e) => {
                    console.error('Video playback error:', e);
                    updateStatus('Error during video playback');
                };
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                updateStatus('Error: Could not access camera. Please check permissions.');
            }
        }
        
        function stopCamera() {
            if (cameraStream) {
                // Stop all tracks
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
                
                // Clear video source
                cameraVideo.srcObject = null;
                
                // Dispose of texture
                if (cameraTexture) {
                    cameraTexture.dispose();
                    cameraTexture = null;
                }
                
                // Reset material
                backgroundPlane.material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0
                });
                backgroundPlane.material.needsUpdate = true;
                
                updateStatus('Camera stopped');
                document.getElementById('startCamera').disabled = false;
                document.getElementById('stopCamera').disabled = true;
            }
        }
        
        function onVideoSelect() {
            const selectedVideo = document.getElementById('videoSelect').value;
            if (selectedVideo) {
                document.getElementById('playVideo').disabled = false;
                updateStatus(`Selected: ${selectedVideo}`);
            } else {
                document.getElementById('playVideo').disabled = true;
                document.getElementById('stopVideo').disabled = true;
            }
        }
        
        function playVideo() {
            const selectedVideo = document.getElementById('videoSelect').value;
            if (!selectedVideo) return;
            
            // Create or update video element
            if (videoElement) {
                videoElement.pause();
            }
            
            videoElement = document.createElement('video');
            videoElement.src = videoUrls[selectedVideo];
            videoElement.crossOrigin = 'anonymous';
            videoElement.loop = true;
            videoElement.muted = true;
            videoElement.autoplay = true;
            videoElement.playsInline = true;
            
            videoElement.addEventListener('canplay', () => {
                videoTexture = new THREE.VideoTexture(videoElement);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                videoTexture.format = THREE.RGBAFormat; // Important for transparency
                
                // Update material with new texture
                videoPlane.material = new THREE.MeshBasicMaterial({
                    map: videoTexture,
                    transparent: true,
                    alphaTest: 0.01,
                    side: THREE.DoubleSide
                });
                videoPlane.material.needsUpdate = true;
                
                videoElement.play();
                isVideoPlaying = true;
                
                updateStatus(`Playing WebM: ${selectedVideo}`);
                document.getElementById('playVideo').disabled = true;
                document.getElementById('stopVideo').disabled = false;
            });
            
            videoElement.addEventListener('error', (e) => {
                console.error('Video error:', e);
                updateStatus('Error: Could not load video');
                document.getElementById('playVideo').disabled = false;
            });
        }
        
        function stopVideo() {
            if (videoElement) {
                videoElement.pause();
                videoElement = null;
            }
            
            if (videoTexture) {
                videoTexture.dispose();
                videoTexture = null;
            }
            
            videoPlane.material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0
            });
            videoPlane.material.needsUpdate = true;
            
            isVideoPlaying = false;
            updateStatus('Video stopped');
            document.getElementById('playVideo').disabled = false;
            document.getElementById('stopVideo').disabled = true;
        }
        
        function onModelSelect() {
            const selectedModel = document.getElementById('modelSelect').value;
            if (selectedModel) {
                document.getElementById('loadModel').disabled = false;
                updateStatus(`Selected: ${selectedModel}`);
            } else {
                document.getElementById('loadModel').disabled = true;
            }
        }
        
        function loadModel() {
            const selectedModel = document.getElementById('modelSelect').value;
            if (!selectedModel) return;
            
            updateStatus(`Loading 3D model: ${selectedModel}...`);
            
            // Remove existing model if any
            if (currentModel) {
                scene.remove(currentModel);
                if (animationMixer) {
                    animationMixer.stopAllAction();
                    animationMixer = null;
                }
                animationActions = [];
            }
            
            gltfLoader.load(
                modelUrls[selectedModel],
                (gltf) => {
                    currentModel = gltf.scene;
                    
                    // Position and scale the model
                    currentModel.position.set(-2, -1, 1);
                    currentModel.scale.set(1, 1, 1);
                    
                    // Add the model to the scene
                    scene.add(currentModel);
                    
                    // Set up animations if available
                    if (gltf.animations && gltf.animations.length > 0) {
                        animationMixer = new THREE.AnimationMixer(currentModel);
                        
                        gltf.animations.forEach((clip) => {
                            const action = animationMixer.clipAction(clip);
                            animationActions.push(action);
                            action.play();
                        });
                        
                        updateStatus(`3D model loaded with ${gltf.animations.length} animations`);
                    } else {
                        updateStatus('3D model loaded (no animations)');
                    }
                    
                    // Update UI
                    document.getElementById('loadModel').disabled = true;
                    document.getElementById('removeModel').disabled = false;
                },
                (progress) => {
                    const percent = Math.round((progress.loaded / progress.total) * 100);
                    updateStatus(`Loading model... ${percent}%`);
                },
                (error) => {
                    console.error('Error loading model:', error);
                    updateStatus('Error: Could not load 3D model');
                }
            );
        }
        
        function removeModel() {
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
                
                if (animationMixer) {
                    animationMixer.stopAllAction();
                    animationMixer = null;
                }
                animationActions = [];
                
                updateStatus('3D model removed');
                
                // Update UI
                document.getElementById('loadModel').disabled = false;
                document.getElementById('removeModel').disabled = true;
            }
        }
        
        function takePhoto() {
            if (isCounting) return;
            
            startCountdown(() => {
                // Render the scene to capture the current frame
                renderer.render(scene, camera);
                
                // Get the canvas data as an image
                const canvas = renderer.domElement;
                const dataURL = canvas.toDataURL('image/png');
                
                // Show preview
                const preview = document.getElementById('photo-preview');
                preview.src = dataURL;
                preview.style.display = 'block';
                
                // Create download link
                const link = document.createElement('a');
                link.download = `photo-${Date.now()}.png`;
                link.href = dataURL;
                link.click();
                
                updateStatus('Photo captured and downloaded');
                
                // Hide preview after 3 seconds
                setTimeout(() => {
                    preview.style.display = 'none';
                }, 3000);
            });
        }
        
        function recordVideo() {
            if (isRecording || isCounting) return;
            
            startCountdown(() => {
                startVideoRecording();
            });
        }
        
        function startVideoRecording() {
            try {
                // Get the canvas stream
                const canvas = renderer.domElement;
                const stream = canvas.captureStream(30); // 30 FPS
                
                // Set up MediaRecorder
                const options = {
                    mimeType: 'video/webm;codecs=vp9',
                    videoBitsPerSecond: 2500000 // 2.5 Mbps for good quality
                };
                
                // Fallback for different browsers
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm;codecs=vp8';
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'video/webm';
                    }
                }
                
                mediaRecorder = new MediaRecorder(stream, options);
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    
                    // Show video preview
                    const videoPreview = document.getElementById('video-preview');
                    videoPreview.src = url;
                    videoPreview.style.display = 'block';
                    
                    // Create download link
                    const link = document.createElement('a');
                    link.download = `video-${Date.now()}.webm`;
                    link.href = url;
                    link.click();
                    
                    updateStatus('10-second video captured and downloaded');
                    
                    // Hide preview after 5 seconds
                    setTimeout(() => {
                        videoPreview.style.display = 'none';
                        URL.revokeObjectURL(url);
                    }, 5000);
                    
                    // Reset UI
                    document.getElementById('recordVideo').disabled = false;
                    document.getElementById('stopRecording').style.display = 'none';
                    document.getElementById('recordVideo').style.display = 'inline-block';
                    isRecording = false;
                };
                
                // Start recording
                mediaRecorder.start(100); // Record in 100ms chunks
                isRecording = true;
                
                // Update UI
                document.getElementById('recordVideo').disabled = true;
                document.getElementById('stopRecording').disabled = false;
                document.getElementById('stopRecording').style.display = 'inline-block';
                document.getElementById('recordVideo').style.display = 'none';
                
                // Show recording indicator
                const indicator = document.getElementById('recording-indicator');
                const countdownElement = document.getElementById('countdown');
                indicator.style.display = 'block';
                
                let timeLeft = 10;
                countdownElement.textContent = timeLeft;
                
                countdownTimer = setInterval(() => {
                    timeLeft--;
                    countdownElement.textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(countdownTimer);
                    }
                }, 1000);
                
                // Auto-stop after 10 seconds
                recordingTimer = setTimeout(() => {
                    stopRecording();
                }, 10000);
                
                updateStatus('Recording 10-second video...');
                
            } catch (error) {
                console.error('Error starting video recording:', error);
                updateStatus('Error: Could not start video recording');
            }
        }
        
        function stopRecording() {
            if (!isRecording) return;
            
            // Stop recording
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            // Clear timers
            if (recordingTimer) {
                clearTimeout(recordingTimer);
                recordingTimer = null;
            }
            
            if (countdownTimer) {
                clearInterval(countdownTimer);
                countdownTimer = null;
            }
            
            // Hide recording indicator
            document.getElementById('recording-indicator').style.display = 'none';
            
            updateStatus('Recording stopped');
        }
        
        function startCountdown(callback) {
            if (isCounting) return;
            
            isCounting = true;
            const countdownOverlay = document.getElementById('countdown-overlay');
            countdownOverlay.style.display = 'block';
            
            let count = 3;
            countdownOverlay.textContent = count;
            
            captureCountdownTimer = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownOverlay.textContent = count;
                    // Trigger animation by removing and re-adding class
                    countdownOverlay.style.animation = 'none';
                    setTimeout(() => {
                        countdownOverlay.style.animation = 'countdownPulse 1s ease-in-out';
                    }, 10);
                } else {
                    countdownOverlay.textContent = 'GO!';
                    setTimeout(() => {
                        countdownOverlay.style.display = 'none';
                        isCounting = false;
                        clearInterval(captureCountdownTimer);
                        callback();
                    }, 500);
                }
            }, 1000);
            
            updateStatus('Get ready... 3, 2, 1...');
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            
            // Update animations
            if (animationMixer) {
                animationMixer.update(deltaTime);
            }
            
            // Update video texture if playing
            if (videoTexture && isVideoPlaying) {
                videoTexture.needsUpdate = true;
            }
            
            // Update camera texture
            if (cameraTexture) {
                cameraTexture.needsUpdate = true;
            }
            
            // Rotate video plane slightly for visual interest
            if (videoPlane.material.opacity > 0) {
                videoPlane.rotation.y = Math.sin(Date.now() * 0.001) * 0.1;
            }
            
            // Rotate 3D model slightly if present
            if (currentModel) {
                currentModel.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // Initialize the app
        init();
    </script>
</body>
</html>